---
import { getCollection, type CollectionEntry } from 'astro:content'
import Base from '../layouts/Base.astro'
import { join } from 'path'
import { readMeta } from '../lib/meta'
import { renderJupyterNotebook } from '../lib/markdown'
import ReadingWidth from '../layouts/ReadingWidth.astro'
import Page from '../layouts/Page.astro'

type Collection = Parameters<typeof getCollection>[0]

interface Props<C extends Collection = Collection> {
  slug: string
  extension: string
  collection: C
  entry: CollectionEntry<C>
}

interface StaticPaths {
  params: {
    slug: string
  }
  props: Props
}

// 1. Generate a new path for every collection entry
export async function getStaticPaths(): Promise<StaticPaths[]> {
  const slugSegments: Record<Collection, string> = {
    random: 'random',
    photography: 'photography',

    'blog-md': 'blog',
    'blog-ipynb': 'blog',

    'docs-md': 'docs',
    'docs-ipynb': 'docs',
  }

  const collections: Collection[] = [
    'random',
    'photography',
    'blog-md',
    'blog-ipynb',
    'docs-md',
    'docs-ipynb',
  ]

  const readCollection = async (
    collection: Collection
  ): Promise<StaticPaths[]> => {
    const entries = await getCollection(collection)

    return entries.map((entry) => {
      const [path, extension] = entry.id.split('.')
      const base = slugSegments[collection]
      const slug = `${base}/${path}`

      return {
        params: { slug },
        props: { collection, slug, extension, entry },
      }
    })
  }

  const staticPaths = await Promise.all(collections.map(readCollection))

  return staticPaths.flat()
}

const renderIpynb = async (props: Props) => {
  const html = await renderJupyterNotebook(
    `./src/content/${props.collection}/${props.entry.id}`
  )

  return { Content: html }
}

const renderers = {
  'blog-md': (entry: Props<'blog-md'>) => entry.entry.render(),
  'blog-ipynb': (entry: Props<'blog-ipynb'>) => renderIpynb(entry),
  'docs-md': (entry: Props<'docs-md'>) => entry.entry.render(),
  'docs-ipynb': (entry: Props<'docs-ipynb'>) => renderIpynb(entry),
  photography: (entry: Props<'photography'>) => entry.entry.render(),
  random: (entry: Props<'random'>) => entry.entry.render(),
}

// 2. When it's time to render, you can get the entry directly from the prop
const { props } = Astro
const { Content } = await renderers[props.entry.collection](props)

const { title, subtitle, description } = props.entry.data
---

<Base title={title} description={description}>
  <Page>
    <article>
      <h1>{title}</h1>
      <h2>{subtitle}</h2>

      {typeof Content === 'string' ? <div set:html={Content} /> : <Content />}
    </article>
  </Page>
</Base>
