---
title: Type-first development
subtitle: 15 September 2025
published: false
---

<site-presentation />

<site-presentation-slide centered>
<section>

# ZOOOOOOOM

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Code + Demo Next to Each Other

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Me

> Hi, I'm Nabeel Valley

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# What we're going to talk about

- Why types matter
- Effectively modeling your data
- Using types to prevent invalid states

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Runtime vs Compile Time

> Types don't exist at runtime!

- The compiler checks types
- Unit tests check runtime
- Type-only changes cannot create bugs
	- Low risk to add
	- Low risk to remove

> The more we can put into our types, the less we need to test

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Good Types

Good types allow us to:

- Eliminate incorrect application state
- Enforce business logic
- Enable composition of business concepts
- Simplify testing
- Document code and processes
- Make Autocomplete really nice

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Compiler Guarantees

- Controlled types means the compiler is our tester
- We don't need to test code with invalid types
- Scopes tests to specifically
	- Complex logic
	- Type-casting code

> Using `any` in your code takes away these guarantees

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Reference Example

We'll use a multi-step form as an example usecase:

1. Input amount
2. Select accounts
3. Confirm details
4. Submit

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Part 1 - The Initial Form

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Base`

> Code + Demo running alongside each other

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## An Initial Model

> How do we define the data that our form holds?

```ts
type TransferForm = {
  amount: number
  accountFrom: string
  accountTo: string
  confirmation?: boolean
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Part 2 - Code is Always Changing

- Adding features to existing code is challenging
- When our types aren't good, we may not catch some bugs

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Bug 1`

- Changing requirements
- Add a new step to the form
- Backend requires that amount is in between `0` and `1 000 000`

> Code + Demo running alongside each other

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Where is the bug?

- During the input validation?
- Between our state changes?
- During form submission?

> Loose types make it difficult to track down sources of invalid data

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Investigate the Model

> Can I see the business rules easily from this type alone?

```ts
// does this represent a completed form or an in-progress one?
type TransferForm = {
	// is this any number?
  amount: number

	// do these strings have some specific format?
	// how does this related to other data?
	// can i fill these in before an amount is selected?
  accountFrom: string
  accountTo: string

	// what does it mean if this is `undefined`?
	// does it make sense for this to be `true` if the form is incomplete?
  confirmation?: boolean
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Evolving our Types

> Can we represent our data better so we can more easily follow it through our application?

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Can we better type our primitives?

```ts
type TransferAmount = number //??
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Branded Types

- Provides domain context to type
- Enables more robust validation
- Do not add runtime overhead
- Usually consist of
	- A primitive value
	- A private brand indicator

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## What is an Amount?

> What business rules do we have around this?

- Represents â‚¬
- Must be positive
- Must be less than 1 000 000

</section>
</site-presentation-slide>

</site-presentation-slide>

<site-presentation-slide centered>
<section>
	
## Defining Branded Types

```ts
// create a compile-time-only value
declare const EuroBrand: unique symbol

type Euro = number & { [EuroBrand]: true }

declare const TransferAmountBrand: unique symbol

// a transfer amout is a Euro + some validation
type TransferAmount = Euro & { [TransferAmountBrand]: true }
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Creating a Euro Amount

> Branding is usually done via a function

```ts
// We can create a Euro value from any number
function euro(value: number): Euro {
	// simply casts the value, does not modify it
  return value as Euro
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Validation

Once we have a Euro value, we can determine if it's a valid transfer amount

- We want to encode this validation in the Types
- Type predicates let us check that something is a given type
- Assertion functions let us throw if it is not a given type

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section> 

## Type Predicates

- Conditionally narrow the type of something

```ts
// We can check if a Euro value is a Valid Transfer Amount
function isTransferAmount(amount: Euro): amount is TransferAmount {
  return amount > 0 && amount < 1_000_000
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Using a Type Predicate

Predicates prevent us from doing type-specific things in places where the result is not true:

```ts
function doSomething(amount: Euro) {
  if (isTransferAmount(amount)) {
    // No Error
    const valid: TransferAmount = amount
  }


  // @ts-expect-error Error: Type 'Euro' is not assignable to type 'TransferAmount'
  const invalid: TransferAmount = amount
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## What about the Confirmation

```ts
type Confirmation = boolean | undefined
```
We don't always need fancy types, usually we just need to think about what we have

- Initially represented as an optional boolean:
- What if it's undefined? Do we really only have two states?
- Is `undefined` the same as `false`
	- Assume that `false === denied` and `undefined === not yet selected`

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Union Types

- Represents one of a fixed list of types
- Useful for representing a set of explicit states

```ts
type Confirmation = 'pending' | 'accepted' | 'denied'
```

</section>
</site-presentation-slide>


<site-presentation-slide centered>
<section>

## Relationships Between Types

Can we narrow an `account` down more specifically than `string`?

```ts
type AccountReference = string //??
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Deriving Types

- Single source of truth
- Identify relationships between types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Generic Types

- Have input arguments, and an output type
- Allow us to compose types from other types

> Generic types are like functions that work at the type level

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Builtin Generic Types

- Typescript has a bunch of Generic types builtin
- All builtin types can be re-created from scratch

```ts
// makes all properties optional
type PartialData = Partial<Data>

// makes all properties required
type RequiredData = Required<Data>

// selects specific properties of data
type PickedData = Pick<Data, 'amount' | 'accountFrom'>
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Defining a Reference Type

A generic type that lets us take anything that looks like a `Model` and get it's ID

```ts
// a model is something with an id
interface Model {
  id: unknown
}

// a "reference" is based on the type of the id of a Model
// the `extends` keyword here works as a constraint
type Reference<M extends Model> = M['id']

// very similar to a generic function that would do the same
function reference<M extends Model>(model: M): Reference<M> {
  return model.id
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Deriving the Account Type

We can use the type function with our `AccountModel`

```ts
type AccountModel = {
  id: `ACC-${number}`
}

type AccountRef = Reference<AccountModel>

// similarly we can preload the generic function
const accountReference = reference<AccountModel>
//    ^? (model: AccountModel) => Reference<AccountModel>
```

> If `AccountModel` ever changes, `AccountRef` will also change

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## The Updated Model

We can define the model we had above a bit more concretely now:

```ts
type TransferForm = {
  amount: TransferAmount
  accountFrom: AccountRef
  accountTo: AccountRef
  confirmation: Confirmation
}
```

> This clears up any questions we had about the field

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Update the Types

- Updated all code to use the new model
- Can we rely on the compiler for any hints about our bug now?

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# My Compiler is Sad

> We've made updates to all our types, but now the compiler has some issues

```
âœ˜ [ERROR] TS2345: Argument of type 'undefined' is not assignable to parameter of type 'Confirmation'. [plugin angular-compiler]

    src/app/accounts-service.ts:24:40:
      24 â”‚     const result = signal<Confirmation>(undefined)

âœ˜ [ERROR] TS2322: Type 'Euro' is not assignable to type 'TransferAmount'.
  Property '[TransferAmountBrand]' is missing in type 'Number & { [EuroBrand]: true; }' but required in type '{ [TransferAmountBrand]: true; }'. [plugin angular-compiler]

    src/app/amount-step/amount-step.ts:53:25:
      53 â”‚     this.onSubmit.emit({ amount });
         â•µ                          ~~~~~~

  '[TransferAmountBrand]' is declared here.

    src/app/types.ts:15:38:
      15 â”‚ export type TransferAmount = Euro & { [TransferAmountBrand]: true };
         â•µ                                       ~~~~~~~~~~~~~~~~~~~~

  The expected type comes from property 'amount' which is declared here on type 'Pick<TransferForm, "amount">'

    src/app/types.ts:47:2:
      47 â”‚   amount: TransferAmount;
         â•µ   ~~~~~~
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Quick Fixes

- The compiler tells us where something isn't what it expects
- We can add the necessary validation and initialization

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Bug 2`

- Later on, we do some refactoring
- We now see that the form ordering is broken for some reason
- Fix this issue

> Code + Demo running alongside each other

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# How can prevent this?

> Looking at our form's code we see this

```ts
label = signal<'Amount' | 'Accounts' | 'Complete' | 'Confirmation'>('Amount');
state = signal<Partial<Types.TransferForm>>({});
```

- There isn't a clear definition of the different states the form can be in
- Can we tie all the valid states together to ensure things remain in sync?

</section>
</site-presentation-slide>


<site-presentation-slide centered>
<section>

## Modeling the Process

- The form is made of distinct steps
- Each state builds up the form's state 

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Relate the Model to the Process

Looking at our steps, we can break the model into these parts:

```ts
// at the start, we have an empty object
type TransferForm = {
	// at the end of step 1, this is defined
  amount: TransferAmount

	// at the end of step 2, this is defined
  accountFrom: AccountRef
  accountTo: AccountRef

	// at the end of step 3, this is defined
  confirmation: Confirmation
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Defining a Single Step

- **The form is made up of multiple steps**
- Data from steps are merged together to create the final model
- Each step has a name so we can easily distinguish

```ts
// Each step has the name of the step + the data that results from that step
type Step<
  Label extends string,
  Data extends Record<string, unknown>
> = {
    label: Label;
    data: Data
  }
```

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Defining the Steps

> The step we're in does not include the data resulting from that step

```ts
type AmountStep = Step<'Amount', {}>;

type AccountStep = Step<'Accounts', Pick<TransferForm, 'amount'>>;

type ConfirmationStep = Step<'Confirmation', Pick<TransferForm, 'amount' | 'accountFrom' | 'accountTo'>>;

type CompleteStep = Step<'Complete', TransferForm>
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Possible Form States

```ts
type TransferFormState = AmountStep | AccountStep | ConfirmationStep | CompleteStep
```

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Strict`

Having a strictly controlled state like this means that:

- We don't need to re-validate data
- A valid state implies that all previous validation was done
- The type system will not allow missing/partial data

> Code + Demo running alongside each other

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## How does the Compiler Protect Us?

- Making changes to the states will break during compilation
- We don't need to unit test the invalid states that were previously possible
- When types are strict we can rely on the compiler to catch cases we've missed

> The amount of benefit you get depends on the strictness of your types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# How Far Should we Go?

- This is probably enough for most implementations
- Use a union type if this is a once-off
- Keep your types simple
  - Different teams have different appetites for complexity
  - Unnecessary complexity can impact 

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Thinking Like A Library Author

> Types can get more complex as our usecases become more generic

Some tools for highly generic types that are also handy to be aware of:

- Mapped types and Recursion for deriving complex types
- `extends` for conditional types
- `infer` for asking the compiler for information

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Using _Any_

> `any` will destroy all benefits of strong types

- It tells the compiler to ignore type checking for a specific value
- This allows unsafe data to move through code that should be safe

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Recap

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Interrogate Your Models

- Question why fields in your model are the type they are
- Define core truths and relationships between models
- Think about what data types can accurately represent them

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Create and Compose Good Types

- Branded Types
- Generic Types
- Assertion Functions
- Type Predicates
- Union Types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Model Your Business Processes

- Tightly model how your state changes and moves through a system
- Leverage the compiler by giving it as much information as possible

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# References & Further Reading

- https://nabeelvalley.co.za/talks/2024/13-03/check-your-domain
- https://www.learningtypescript.com/articles/branded-types
- https://www.lucaspaganini.com/academy/assertion-functions-typescript-narrowing-5/
- https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions
- https://www.typescriptlang.org/docs/handbook/utility-types.html

</section>
</site-presentation-slide>
