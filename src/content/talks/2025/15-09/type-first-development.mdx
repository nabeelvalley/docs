---
title: Type-first development
subtitle: 15 September 2025
published: false
---

<site-presentation />

<site-presentation-slide centered>
<section>

# ZOOOOOOOM

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Me

> Hi, I'm Nabeel Valley

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Type-first development with Typescript

- Types as a base
- Business logic as transformations
- Compiler guides implementation

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# What we're going to talk about

- Why types matter
- Effectively modeling your models
- Using types to prevent invalid states

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Runtime vs Compile Time

> Types don't exist at runtime!

- The compiler checks types
- Unit tests check runtime
- Type-only changes cannot create bugs
	- Low risk to add
	- Low risk to remove

> The more we can put into our types, the less we need to test

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Good Types

Good types allow us to:

- Eliminate incorrect application state
- Enforce business logic
- Enable composition of business concepts
- Simplify testing
- Document code and processes
- Make Autocomplete really nice

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Compiler Guarantees

- Controlled types means the compiler is our tester
- We don't need to test code with invalid types
- Scopes tests to specifically
	- Complex logic
	- Type-casting code

> Using `any` in your code takes away these guarantees

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Reference Example

We'll use a multi-step form as an example usecase:

1. Input amount
2. Select accounts
3. Confirm details
4. Submit

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Part 1 - The Initial Form

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Base`

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## An Initial Model

> How do we define the data that our form holds?

```ts
type TransferForm = {
  amount: number
  accountFrom: string
  accountTo: string
  confirmation?: boolean
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Part 2 - Code is Always Changing

- Adding features to existing code is challenging
- When our types aren't good, we may not catch some bugs

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Bug 1`

- Changing requirements
- Add a new step to the form
- Backend requires that amount is in between `0` and `1 000 000`

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Where is the bug?

- During the input validation?
- Between our state changes?
- During form submission?

> Loose types make it difficult to track down sources of invalid data

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Investigate the Model

> Can I see the business rules easily from this type alone?

```ts
// does this represent a completed form or an in-progress one?
type TransferForm = {
	// is this any number?
  amount: number

	// do these strings have some specific format?
	// how does this related to other data?
	// can i fill these in before an amount is selected?
  accountFrom: string
  accountTo: string

	// what does it mean if this is `undefined`?
	// does it make sense for this to be `true` if the form is incomplete?
  confirmation?: boolean
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Evolving our Types

> Can we represent our data better so we can more easily follow it through our application?

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Can we better type our primitives?

```ts
type TransferAmount = number //??
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Branded Types

- A wrapper over primitive values
- Provides domain context
- Enables more robust validation
- Do not add runtime overhead

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## What is an Amount?

> What business rules do we have around this?

- Represents â‚¬
- Must be positive
- Must be less than 1 000 000

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Defining a Brand

- Do not modify the original object
- Can be defined in a variety of ways
- Exist only at the type level
- Store validation in the type language
- Usually consist of
	- A primitive value
	- A private brand indicator

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>
	
## Defining Branded Types

```ts
// create a compile-time-only value
declare const EuroBrand: unique symbol

type Euro = number & { [EuroBrand]: true }

declare const TransferAmountBrand: unique symbol

// a transfer amout is a Euro + some validation
type TransferAmount = Euro & { [TransferAmountBrand]: true }
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Creating a Euro Amount

> Branding is usually done via a function

```ts
// We can create a Euro value from any number
function euro(value: number): Euro {
	// simply casts the value, does not modify it
  return value as Euro
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Validation

Once we have a Euro value, we can determine if it's a valid transfer amount

- We want to encode this validation in the Types
- Type predicates let us check that something is a given type
- Assertion functions let us throw if it is not a given type

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section> 

## Type Predicates

- Conditionally narrow the type of something

```ts
// We can check if a Euro value is a Valid Transfer Amount
function isTransferAmount(amount: Euro): amount is TransferAmount {
  return amount > 0 && amount < 1_000_000
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Using a Type Predicate

Predicates prevent us from doing type-specific things in places where the result is not true:

```ts
function doSomething(amount: Euro) {
  if (isTransferAmount(amount)) {
    // No Error
    const valid: TransferAmount = amount
  }


  // @ts-expect-error Error: Type 'Euro' is not assignable to type 'TransferAmount'
  const invalid: TransferAmount = amount
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Relationships Between Types

Can we narrow an `account` down more specifically than `string`?

```ts
type AccountReference = string //??
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Deriving Types

- Single source of truth
- Identify relationships between types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Generic Types

- Have input arguments, and an output type
- Allow us to compose types from other types

> Generic types are like functions that work at the type level

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Builtin Generic Types

- Typescript has a bunch of Generic types builtin
- All builtin types can be re-created from scratch

```ts
// makes all properties optional
type PartialData = Partial<Data>

// makes all properties required
type RequiredData = Required<Data>

// selects specific properties of data
type PickedData = Pick<Data, 'amount' | 'accountFrom'>
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Defining a Reference Type

A generic type that lets us take anything that looks like a `Model` and get it's ID

```ts
// a model is something with an id
interface Model {
  id: unknown
}

// a "reference" is based on the type of the id of a Model
// the `extends` keyword here works as a constraint
type Reference<M extends Model> = M['id']

// very similar to a generic function that would do the same
function reference<M extends Model>(model: M): Reference<M> {
  return model.id
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Deriving the Account Type

We can use the type function with our `AccountModel`

```ts
type AccountModel = {
  id: `ACC-${number}`
}

type AccountRef = Reference<AccountModel>

// similarly we can preload the generic function
const accountReference = reference<AccountModel>
//    ^? (model: AccountModel) => Reference<AccountModel>
```

> If `AccountModel` ever changes, `AccountRef` will also change

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## What about the Confirmation

```ts
type Confirmation = boolean | undefined
```
We don't always need fancy types, usually we just need to think about what we have

- Initially represented as an optional boolean:
- What if it's undefined? Do we really only have two states?
- Is `undefined` the same as `false`
	- Assume that `false == denied` and `undefined == not yet selected`

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Union Types

- Represents one of a fixed list of types
- Useful for representing a set of explicit states

```ts
type Confirmation = 'pending' | 'accepted' | 'denied'
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## The Updated Model

We can define the model we had above a bit more concretely now:

```ts
type TransferForm = {
  amount: TransferAmount
  accountFrom: AccountRef
  accountTo: AccountRef
  confirmation: Confirmation
}
```

> This clears up any questions we had about the field

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Update the Types

- Updated all code to use the new model
- Can we rely on the compiler for any hints about our bug now?

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# My Compiler is Sad

> We've made updates to all our types, but now the compiler has some issues

```
âœ˜ [ERROR] TS2345: Argument of type 'undefined' is not assignable to parameter of type 'Confirmation'. [plugin angular-compiler]

    src/app/accounts-service.ts:24:40:
      24 â”‚     const result = signal<Confirmation>(undefined)

âœ˜ [ERROR] TS2322: Type 'Euro' is not assignable to type 'TransferAmount'.
  Property '[TransferAmountBrand]' is missing in type 'Number & { [EuroBrand]: true; }' but required in type '{ [TransferAmountBrand]: true; }'. [plugin angular-compiler]

    src/app/amount-step/amount-step.ts:53:25:
      53 â”‚     this.onSubmit.emit({ amount });
         â•µ                          ~~~~~~

  '[TransferAmountBrand]' is declared here.

    src/app/types.ts:15:38:
      15 â”‚ export type TransferAmount = Euro & { [TransferAmountBrand]: true };
         â•µ                                       ~~~~~~~~~~~~~~~~~~~~

  The expected type comes from property 'amount' which is declared here on type 'Pick<TransferForm, "amount">'

    src/app/types.ts:47:2:
      47 â”‚   amount: TransferAmount;
         â•µ   ~~~~~~
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Quick Fixes

- The compiler tells us where something isn't what it expects
- We can add the necessary validation and initialization

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Bug 2`

- Later on, we do some refactoring
- We now see that the form ordering is broken for some reason

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Modeling the Process

- The form is made of distinct steps
- Each state builds up the form's state 

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Relate the Model to the Process

Looking at our steps, we can break the model into these parts:

```ts
// at the start, we have an empty object
type TransferForm = {
	// at the end of step 1, this is defined
  amount: TransferAmount

	// at the end of step 2, this is defined
  accountFrom: AccountRef
  accountTo: AccountRef

	// at the end of step 3, this is defined
  confirmation: Confirmation
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Defining a Single Step

- **The form is made up of multiple steps**
- Data from steps are merged together to create the final model
- Each step has a name so we can easily distinguish

```ts
// Each step has the name of the step + the data that results from that step
type Step<
  Label extends string,
  Data extends Record<string, unknown>
> = {
    label: Label;
    data: Data
  }
```

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## Defining the Steps

> The step we're in does not include the data resulting from that step

```ts
type AmountStep = Step<'Amount', {}>;

type AccountStep = Step<'Accounts', Pick<TransferForm, 'amount'>>;

type ConfirmationStep = Step<'Confirmation', Pick<TransferForm, 'amount' | 'accountFrom' | 'accountTo'>>;

type CompleteStep = Step<'Complete', TransferForm>
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Possible Form States

```ts
type TransferFormState = AmountStep | AccountStep | ConfirmationStep | CompleteStep
```

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

# Demo - `Strict`

Having a strictly controlled state like this means that:

- We don't need to re-validate data
- A valid state implies that all previous validation was done
- The type system will not allow missing/partial data

</section>
</site-presentation-slide>

<site-presentation-slide centered highlight>
<section>

## How does the Compiler Protect Us?

- Making changes to the states will break during compilation
- We don't need to unit test the invalid states that were previously possible
- When types are strict we can rely on the compiler to catch cases we've missed

> The amount of benefit you get depends on the strictness of your types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## How Far Should we Go?

- This is probably enough for most implementations
- Use a union type if this is a once-off

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Thinking Like A Library Author

- What if this is meant to be shared?
- How can we provide a good interface for consumers?
- Is complexity okay if it's contained?

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Reduce Repeated Types

- Lots of repetition to define all those states manually
- Easy to make a mistake
- This type can be complex to define

> We can use the tools we've covered to make this more automatic

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## How Does Stepping Look as a Function?

- It's helpful to look at Complex Types as Functions
- Return of the recursion
  - Since we can't use loops in types

> Apologies in advance for the big code snippet you're about to see

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

```ts
function multiStepFormStates(steps: Step[], merged: Step[] = [steps[0]]) {
  // no more steps to merge, so return
  if (steps.length < 2) {
    return merged
  }

  const [current, next, ...rest] = steps

  // each state starts off with only the data from a previous state
  const start: Step = {
    label: next.label,
    data: {
      ...current.data,
    }
  }

  // each step builds on the end state of the next state
  const end: Step = {
    label: next.label,
    data: {
      ...current.data,
      ...next.data
    }
  }

  return multiStepFormStates(
    // pass rest of entries to recurse through
    [end, ...rest],
    // pass results forward
    [...merged, start]
  )
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Putting the Types Together

```ts
type MultiStepFormStates<Steps extends Step[], Merged extends Step[] = [Steps[0]]> = Steps extends [
  infer Current,
  infer Next,
  ...infer Rest,
]
  ? Rest extends Step[]
    // recursive "call" to the "type function"
    ? MultiStepFormStates<
      // use the completed state of the current phase as the starting point for the next
      [EndTransition<Current, Next>, ...Rest],
      // store the start of each step as this is what the step will have
      [...Merged, StartTransition<Current, Next>]
    >
    // rest does not contain steps, this should `never` happen
    : never
  // processed all items, return final result
  : Merged[number]
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Creating the Form Type

Using the `MultiStepFormStates` type, the `TransferFormStates` can be defined as follows

```ts
export type TransferFormState = MultiStepFormStates<
  [InitStep, AmountStep, AccountStep, ConfirmationStep, CompleteStep]
>;
```

> This type is also generic for any multi-step in the application!

</section>
</site-presentation-slide>



<site-presentation-slide centered>
<section>

## Inferring Validity

The state is guaranteed to be valid if we're on a given step

Extracting the final data of the form can be done using the state alone without rev-validating

```ts
// we can now do state name checks
if (state.name === 'confirmation') {
  // valid states mean we don't need to re-validate
  submitForm(state.data)
}
```

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Risks

- Types can have a high complexity-density
	- Small code, big scary (sometimes)
- Overly strict types may be difficult for developers to work with
- `any` can destroy quality of inferred types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Recap

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Interrogate Your Models

- Question why fields in your model are the type they are
- Define core truths and relationships between models
- Think about what data types can accurately represent them

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Look for Composition

- Relationships exist between our models and how we use them
- Typescript has tools for representing these relationships

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Methods of Composing Types

- Branded Types
- Generic Types
- Assertion Functions
- Type Predicates
- Union Types

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

## Tools For Building Complex Types

> Complex types have some similar structures, learn once - use forever

- Mapped Types
- Recursive Types
- `keyof` keyword
- `extends` keyword
- `infer` keyword

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# Why Bother?

- Single source of truth, less to maintain
- The compiler tells you when things break
- Reduced needs for unit testing
- Types document processes
- Great Autocomplete for other Devs
- Low risk
	- Complex types can be replaced with simpler types
	- No runtime impact, type-only refactors can't introduce bugs

</section>
</site-presentation-slide>

<site-presentation-slide centered>
<section>

# References & Further Reading

- https://nabeelvalley.co.za/talks/2024/13-03/check-your-domain
- https://www.learningtypescript.com/articles/branded-types
- https://www.lucaspaganini.com/academy/assertion-functions-typescript-narrowing-5/
- https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions
- https://www.typescriptlang.org/docs/handbook/utility-types.html

</section>
</site-presentation-slide>
